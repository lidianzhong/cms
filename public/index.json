[{"content":"__init__.py 的作用 用于告诉 Python 解释器，该目录是一个包，而不仅仅是一个普通的目录。这样你就可以使用 import 来导入目录中的模块\n同时在 init.py 文件中你也可以做一些必要的设置、定义一些变量等等。\n","permalink":"http://localhost:1313/posts/python/grammar/","summary":"__init__.py 的作用 用于告诉 Python 解释器，该目录是一个包，而不仅仅是一个普通的目录。这样你就可以使用 import 来导入目录中的模块 同时在 init.py 文件中你也可以做一些必要的设置、定义一些变量等等。","title":"python 语法"},{"content":" 介绍目前全球知名的四足机器人研究组织和相关的机器人和四足机器人总体概述\n四足机器人发展现状 波士顿动力公司（Boston Dynamics） 相关机器人：Altas、Stretch、Spot\n麻省理工学院 Biomimetic Robotics Lab 相关机器人：MIT Cheetah、MIT Mini Cheetah\n苏黎世联邦理工学院（ETH Zurich） 相关机器人：ANYmal\n宇树科技（Unitree Robotics）（国内） 相关机器人：Laikago、Aliengo、A1、Go1、Go2\n四足机器人的组成 动力系统 + 控制系统 + 通信系统 + 能源系统\n动力系统：核心是机器人关节电机，需要能够对关节力矩和角度进行精确控制。\n控制系统： 重点是控制算法，比如规划器和运动控制器，能够根据目标路径计算出各个关节需要执行的命令\n通信系统：各个关节电机、传感器、遥控手柄的通信\n能源系统：使用电池或者外部直流电源进行供电\n","permalink":"http://localhost:1313/posts/robot/robot_book/1_overview/","summary":"介绍目前全球知名的四足机器人研究组织和相关的机器人和四足机器人总体概述 四足机器人发展现状 波士顿动力公司（Boston Dynamics） 相关机器人：Altas、Stretch、Spot 麻省理工学院 Biomimetic Robotics Lab 相关机器人：MIT Cheetah、MIT Mini Cheetah 苏黎世联邦理工学院（ETH Zuric","title":"四足机器人概述"},{"content":"ROS与Gazebo ROS 中将每一个进程视作一个节点（Node），节点之间的通信方式依靠：话题（Topic）、服务（Service）、参数（Parameter）。\n控制器（Controller）与仿真（Gazebo）就是两个节点，利用 topic通信。\n过程是：控制器从Gazebo读取机器人各个关节角度、角速度、IMU等数值，然后计算出控制量，如目标力矩、目标关节角度等发送给Gazebo。\n面向对象设计 面向对象的程序设计的三大特性为：封装、继承、多态。\n想象以下的场景：有一个控制器，想要它既可以与仿真环境Gazebo交互，也可以和实际的机器人交互。如何实现？\n封装：将控制器与ROS交互接口的收发功能进行封装，用类中的一个方法加以实现。\n继承：针对仿真模型和真实机器人的两个接口类，IOROS类和IOSDK类。它们用不同的方法完成同一个任务，即收发数据。因此他们有相同的共性，我们可以将这个共性提取到IOInterface类，都用到的函数设定为纯虚函数。\n多态：现在有了两个接口，通过将父类（IOInterface）的指针赋值为IOROS或IOSDK指针的值，可以方便地完成控制器在仿真平台到真实机器人的切换。\n有限状态机 有限状态机不是一个真实的硬件，而是抽象的概念。利用有限状态机可以实现控制器中对各个状态的切换。比如从阻尼模式切换到站立模式。\n有限状态机有五种状态（阻尼模式、固定站立、自由站立等），两种任务。任务一是重复当前运行状态（即重复执行当前状态的run函数），任务二是切换状态。\n实现：让机器人站起来 机器人的关节控制 前面说了如何发送命令给单个电机，以控制电机或读取状态，现在考虑给机器人的12个电机发送电机命令和接收状态。\n相关的类是 FSMState.h，它是有限状态机四个状态的基类，每个状态继承了下面变量：\nCtrlComponents *_ctrlComp;\t// 包含大多数控制所需的类与状态变量 LowlevelCmd *_lowCmd;\t// 发送给各个电机的命令 LowlevelState *_lowState;\t// 从各个电机接收的状态 四足机器人有四条腿，同时每个腿有三个关节。关节顺序是这样定义的：\n每一条腿，自上而下的三个关节为机身关节、大腿关节、小腿关节，顺序分别为 0、1、2。 四条腿，按照右前腿、左前腿、右后腿、左右腿的顺序排列。 0:0 号腿 0 号关节，即右前腿机身关节 1:0 号腿 1 号关节，即右前腿大腿关节 2:0 号腿 2 号关节，即右前腿小腿关节 3:1 号腿 0 号关节，即左前腿机身关节 4:1 号腿 1 号关节，即左前腿大腿关节 5:1 号腿 2 号关节，即左前腿小腿关节 6:2 号腿 0 号关节，即右后腿机身关节 7:2 号腿 1 号关节，即右后腿大腿关节 8:2 号腿 2 号关节，即右后腿小腿关节 9:3 号腿 0 号关节，即左后腿机身关节 10:3 号腿 1 号关节，即左后腿大腿关节 11:3 号腿 2 号关节，即左后腿小腿关节 机器人的阻尼模式 出于安全考虑，一般机器人在开机时默认进入阻尼模式（Passive）。\n阻尼模式的代码src/FSM/State_Passive.cpp：\nvoid State_Passive::enter(){ if(_ctrlComp-\u0026gt;ctrlPlatform == CtrlPlatform::GAZEBO){ for(int i=0; i\u0026lt;12; i++){ _lowCmd-\u0026gt;motorCmd[i].mode = 10; _lowCmd-\u0026gt;motorCmd[i].q = 0; _lowCmd-\u0026gt;motorCmd[i].dq = 0; _lowCmd-\u0026gt;motorCmd[i].Kp = 0; _lowCmd-\u0026gt;motorCmd[i].Kd = 8; _lowCmd-\u0026gt;motorCmd[i].tau = 0; } } else if(_ctrlComp-\u0026gt;ctrlPlatform == CtrlPlatform::REALROBOT){ for(int i=0; i\u0026lt;12; i++){ ...... } } _ctrlComp-\u0026gt;setAllSwing(); } void State_Passive::run(){ } void State_Passive::exit(){ } 可以看到，代码对在仿真平台和真实机器人进行了不同的设定。各个参数的设置放置在了 函数enter中，意味着只有在有限状态机进入阻尼模式时，LowLevelCmd 才修改一次。而 run 和 exit 均为空函数，说明不进行其它操作。但是有限状态机在运行时会不停地发送LowLevelCmd给电机，所以机器人会持续收到阻尼模式的命令。\n在有限状态机中，添加了自动保护功能。checkSafty 函数进行了机身姿态的判断。当checkSafty 返回 false 时，会让机器人的所有关节进入阻尼模式。\n机器人各个关节的坐标系与零角度点 机器人的每个关节需要一个坐标系和零角度点来确定位置和角度\n机器人上所有的坐标系都是右手系，且互相平行。坐标系的 x 轴朝向机器人的前方，y 轴朝向机器人的左侧，z 轴竖直向上。\n机身关节的旋转轴为 x 轴，大腿关节和小腿关节为 y 轴，旋转正方向符合右手定则，使用弧度制。\n这样就可以用数值来表示一个特定的关节状态了。比如机器人站立的状态就可以表示为：\n机身关节：0.00 大腿关节：0.67 小腿关节：-1.30 于是我们就可以在代码中设定目标关节角度：\nfloat_targetPos[12] = {0.0, 0.67, -1.3, 0.0, 0.67, -1.3, 0.0, 0.67, -1.3, 0.0, 0.67, -1.3}; 机器人的固定站立模式 知道了机器人的目标角度，如何实现机器人的固定站立呢？\n对函数 enter、run、exit进行考虑：\n在 enter 函数中，首先将每个关节的期望值设定好，然后再更新最初姿态的变量\nvoid State_FixedStand::enter(){ for(int i=0; i\u0026lt;4; i++){ if(_ctrlComp-\u0026gt;ctrlPlatform == CtrlPlatform::GAZEBO){ _lowCmd-\u0026gt;setSimStanceGain(i);\t// 设置关节期望值 } else if(_ctrlComp-\u0026gt;ctrlPlatform == CtrlPlatform::REALROBOT){ _lowCmd-\u0026gt;setRealStanceGain(i); } _lowCmd-\u0026gt;setZeroDq(i);\t// 设置关节期望值 _lowCmd-\u0026gt;setZeroTau(i);\t// 设置关节期望值 } for(int i=0; i\u0026lt;12; i++){ _lowCmd-\u0026gt;motorCmd[i].q = _lowState-\u0026gt;motorState[i].q; _startPos[i] = _lowState-\u0026gt;motorState[i].q;\t// 设定初始姿态 } _ctrlComp-\u0026gt;setAllStance(); } 在 run 函数中，使用线性插值来完成从最初状态到目标姿态的过渡，每运行一次越靠近目标姿态\nvoid State_FixedStand::run(){ _percent += (float)1/_duration; _percent = _percent \u0026gt; 1 ? 1 : _percent; for(int j=0; j\u0026lt;12; j++){ _lowCmd-\u0026gt;motorCmd[j].q = (1 - _percent)*_startPos[j] + _percent*_targetPos[j]; } } 在 exit 函数中，将 _percent 设置为 0，这样再次切换到站立模式，才能正常运行。\n","permalink":"http://localhost:1313/posts/robot/robot_book/3_ji_qi_ren_fang_zhen_yu_kong_zhi_kuang_jia/","summary":"ROS与Gazebo ROS 中将每一个进程视作一个节点（Node），节点之间的通信方式依靠：话题（Topic）、服务（Service）、参数（Parameter）。 控制器（Controller）与仿真（Gazebo）就是两个节点，利用 topic通信。 过程是：控制器从Gazebo读取机器","title":"机器人仿真与控制框架"},{"content":"出现 LF will be replaced by CRLF in ****** 解决方法：git config core.autocrlf false\n","permalink":"http://localhost:1313/posts/ubuntu/problem/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/","summary":"出现 LF will be replaced by CRLF in ****** 解决方法：git config core.autocrlf false","title":"字符编码问题"},{"content":" 在 WSL2 中运行的有 http://localhost:1188/ 的服务，如何通过 Windows 宿主机进行访问？\n无需任何操作，直接在 Windows 中使用 http://localhost:1188/ 即可访问。\n这种情况只针对于使用的是 localhost\n使用 WSL 访问网络应用程序 | Microsoft Learn\n","permalink":"http://localhost:1313/posts/tools/wsl2/%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AEwsl2%E6%9C%8D%E5%8A%A1/","summary":"在 WSL2 中运行的有 http://localhost:1188/ 的服务，如何通过 Windows 宿主机进行访问？ 无需任何操作，直接在 Windows 中使用 http://localhost:1188/ 即可访问。 这种情况只针对于使用的是 localhost 使用 WSL 访问网络应用程序 | Microsoft Learn","title":"局域网访问WSL2服务"},{"content":"cuda 版本的问题 使用 nvidia-smi 命令显示的 cuda 版本表示支持最高的版本，并不是当前 cuda 的版本。\n查看当前 cuda 版本的命令是使用 nvcc -V 命令，显示的 cuda 版本。\ncuda 版本支持切换，主要是根据 PATH 中的指向来确定的\n切换 cuda 版本的命令如下\n# \u0026lt;version\u0026gt; 须切换的CUDA版本号 export PATH=/usr/local/cuda-\u0026lt;version\u0026gt;/bin${PATH:+:${PATH}} export LD_LIBRARY_PATH=/usr/local/cuda-\u0026lt;version\u0026gt;/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} [解決方案] conda 虚拟环境中 cuda不同版本進行切換（含Linux 和 Windows）_修改cuda版本-CSDN博客\nCUDA的正确安装/升级/重装/使用方式 - 知乎 (zhihu.com)\nubuntu下安装多版本cuda及版本切换教程_ubuntu切换cuda版本-CSDN博客\n","permalink":"http://localhost:1313/posts/ubuntu/py_environment/graphics_card/","summary":"cuda 版本的问题 使用 nvidia-smi 命令显示的 cuda 版本表示支持最高的版本，并不是当前 cuda 的版本。 查看当前 cuda 版本的命令是使用 nvcc -V 命令，显示的 cuda 版本。 cuda 版本支持切换，主要是根据 PATH 中的指向来确定的 切换 cuda 版本的命令如下 # \u0026lt;version\u0026gt; 须切换的CUDA版本号 export PATH=/usr/local/cuda-\u0026lt;version\u0026gt;/bin${PATH:+:${PATH}} export LD_LIBRARY_PATH=/usr/local/cuda-\u0026lt;version\u0026gt;/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} [解決方案] conda 虚拟环境中 cuda不同版本進行切換（含Lin","title":"GPU 相关"},{"content":"卸载 Conda 环境 conda env remove --name myenv ","permalink":"http://localhost:1313/posts/ubuntu/py_environment/conda_command/","summary":"卸载 Conda 环境 conda env remove --name myenv","title":"Conda 常用命令汇总"},{"content":"安装问题 无法解析的服务器名称，Error code: Wsl/WININET_E_NAME_NOT_RESOLVED PS C:\\Users\\DianzhongLi\u0026gt; wsl --list --online 无法从“https://raw.githubusercontent.com/microsoft/WSL/master/distributions/DistributionInfo.json”中提取列表分发。无法解析服务器的名称或地址 Error code: Wsl/WININET_E_NAME_NOT_RESOLVED 解决方法：\n使用代理或者VPN 在 hosts 中指定 raw.githubusercontent.com 的对应ip 安装 WSL 报错 Error code: Wsl/WININET_E_NAME_NOT_RESOLVED 问题解决-CSDN博客\n屏幕缩放问题 使用 export GDK_DPI_SCALE=1.5 即可解决。\n其它解决方案：https://github.com/microsoft/wslg/issues/23\n不能显示中文字符 sudo mkdir /usr/share/fonts/win11 sudo ln -s /mnt/c/Windows/Fonts/* /usr/share/fonts/win11 ","permalink":"http://localhost:1313/posts/tools/wsl2/wsl2_problem/","summary":"安装问题 无法解析的服务器名称，Error code: Wsl/WININET_E_NAME_NOT_RESOLVED PS C:\\Users\\DianzhongLi\u0026gt; wsl --list --online 无法从“https://raw.githubusercontent.com/microsoft/WSL/master/distributions/DistributionInfo.json”中提取列表分发。无法解析服务器的名称","title":"Wsl2_problem"},{"content":"安装带图形化的 Ubuntu 使用 WSL 运行 Linux GUI 应用 | Microsoft Learn\n常用命令 在编辑器中启动 bashrc 文件：gnome-text-editor ~/.bashrc\nGNOME 桌面的文件管理器：nautilus\n多媒体播放器：vlc\nLinux 的 Google Chrome：google-chrome\nwsl2安装ssh Windows 11 安装 WSL2 并ssh远程连接 - 麦克斯的园丁 - 博客园 (cnblogs.com)\nwsl2安装 vscode 开始通过 WSL 使用 VS Code | Microsoft Learn\n卸载wsl2中的 vscode Uninstall Visual Studio Code\n","permalink":"http://localhost:1313/posts/tools/wsl2/wsl2_install/","summary":"安装带图形化的 Ubuntu 使用 WSL 运行 Linux GUI 应用 | Microsoft Learn 常用命令 在编辑器中启动 bashrc 文件：gnome-text-editor ~/.bashrc GNOME 桌面的文件管理器：nautilus 多媒体播放器：vlc Linux 的 Google Chrome：google-chrome wsl2安装ssh Windows 11 安装 WSL2 并ssh远程连接 - 麦克斯的园丁 - 博客园 (cnblogs.com) ws","title":"Wsl2_install"},{"content":"apt 清华源 配置地址：/etc/apt/sources.list\nubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n解压 tar.gz 文件 tar -xzvf filename.tar.gz 清华 conda 镜像 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/linux-64/ conda config --set show_channel_urls yes pip 清华源 临时使用：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package\n设为默认：pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\npypi | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n根据 PID 来查看详细的进程信息 ps -f -p 2508841 Ubuntu进程管理查看当前GPU占用情况及哪个用户在使用 - DuanYongchun - 博客园 (cnblogs.com)\n","permalink":"http://localhost:1313/posts/ubuntu/common_command/common_command/","summary":"apt 清华源 配置地址：/etc/apt/sources.list ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror 解压 tar.gz 文件 tar -xzvf filename.tar.gz 清华 conda 镜像 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/linux-64/ conda config --set show_channel_urls yes pip 清华源 临时使用：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package 设为默认：pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple pypi | 镜像站使用帮助 | 清华大学开源软件","title":"Ubuntu 常用命令汇总"},{"content":"使用间接寻址访问内存中的指令 [0] 表示访问内存地址为 0 的位置，[bx] 表示访问内存地址为 bx 寄存器值的位置。\n; 从内存地址为 0x1000 的位置读取一个字节 mov bx, 0x1000 ; 将 0x1000 存入 bx 寄存器 mov al, [bx] ; 从内存地址为 bx 的位置读取一个字节，存入 al 寄存器 使用 and 和 or 实现内存定位 and 指令：按位进行与运算，可以将相应位设为0，其它位不变\nor 指令：按位或运行，可以将相应位设为1，其它位不变\nand al, 101111111B ;将al的第六位设为0 and al, 111111110B ;将al的第0位设为0 or al, 010000000B ; 将al的第六位设为1 实例：汇编中实现大小写转换 解决大小写转换问题：在汇编中不是考虑通过加减20H将大写转化为小写，或者小写转化为大写，而是采用大写第五位置0，小写第五位置1。比如 A 的二进制为 01000001，而小写 a 的二进制为 01100001。\nloop 函数如何实现：loop 指令是一个循环指令，它首先减少 CX 寄存器中的值，然后检查 CX 是否为零。如果 CX 不为零，则跳转到标签 s 处执行循环内的指令。如果 CX 为零，则程序继续执行下一条指令。\nASSUME CS:codesg, DS:datasg\t; 指定段寄存器的默认段值 datasg SEGMENT db \u0026#39;BaSiC\u0026#39;\t; 存储字符串，使用 \u0026#39;.......\u0026#39; 表示字符串 db \u0026#39;iNfOrMaTiOn\u0026#39; datasg ENDS codesg SEGMENT START: mov ax, datasg mov ds, ax mov bx, 0 mov cx, 5 s: mov al, [bx]\t; 循环 5 次，每次修改一个字母 and al, 11011111b\t; 这一步，将字母变成大写 mov [bx], al inc bx\t; bx 寄存器中的值加一 loop s mov bx, 5 mov cx, 11 s0: mov al, [bx] or al, 00100000b\t; 这一步，将字母变成小写 mov [bx], al inc bx loop s0 mov ax, 4c00h int 21h codesg ENDS END START [bx + idata] [bx + idata] 表明一个内存单元，它的偏移地址为 (bx) + idata(bx 中的数值加上 idata)。\n比如，mov ax,[bx + 200]，数学描述为 (ax) + ((ds) * 16 + (bx) + 200)\n这样，上面的大小写转换可以使用类似数组的方式实现\nASSUME CS:codesg, DS:datasg datasg SEGMENT db \u0026#39;BaSiC\u0026#39; db \u0026#39;iNfOrMaTiOn\u0026#39; datasg ENDS codesg SEGMENT START: mov ax, datasg mov ds, ax mov bx, 0 mov cx, 5 s: mov al, [bx] and al, 11011111b mov [bx], al mov [5 + bx], al inc bx loop s mov ax, 4c00h int 21h codesg ENDS END START SI 和 DI bx：在x86架构的汇编语言中，BX 寄存器通常用作地址寄存器，用于间接寻址。\nsi（Source Index）寄存器：通常用于指向源数据的内存地址。\ndi（Destination Index）寄存器：通常用于指向目标数据的内存地址。\n在一些情况下，它们也可被用于通用的寄存器。\n[bx + si] 和 [bx + di] 基址加索引寻址：\n[bx + si]：这种寻址方式表示的是以 bx 寄存器的值为基址，si 寄存器的值为偏移量的内存地址。例如，如果 bx 的值是 0x1000，si 的值是 0x0040，那么 [bx + si] 就表示的是内存地址 0x1040。 [bx + di]：这种寻址方式表示的是以 bx 寄存器的值为基址，di 寄存器的值为偏移量的内存地址。例如，如果 bx 的值是 0x2000，di 的值是 0x0080，那么 [bx + di] 就表示的是内存地址 0x2080。 [bx + si + idata] 和 [bx + si + idata] 基址加索引加位移寻址:\n[bx + si + idata]：这种寻址方式表示的是以 bx 寄存器的值为基址，si 寄存器的值为索引，idata 为一个立即数偏移量的内存地址。例如，如果 bx 的值是 0x1000，si 的值是 0x0040，idata 的值是 0x0002，那么 [bx + si + idata] 就表示的是内存地址 0x1042。 [bx + di + idata]：这种寻址方式表示的是以 bx 寄存器的值为基址，di 寄存器的值为索引，idata 为一个立即数偏移量的内存地址。例如，如果 bx 的值是 0x2000，di 的值是 0x0080，idata 的值是 0x0004，那么 [bx + di + idata] 就表示的是内存地址 0x2084。 案例：将 datasg 中每个字符改为大写字母 题目是这样的，将其中的字母都转为大写。\ndatasg SEGMENT db \u0026#39;ibm \u0026#39; db \u0026#39;dec \u0026#39; db \u0026#39;dos \u0026#39; db \u0026#39;vax \u0026#39; datasg ENDS 考虑到这类似于 C++ 中实现两层 for 循环遍历修改一样，考虑使用两层 loop 循环用汇编实现相似功能\nASSUME CS:codesg DS:datasg datasg SEGMENT db \u0026#39;ibm \u0026#39; db \u0026#39;dec \u0026#39; db \u0026#39;dos \u0026#39; db \u0026#39;vax \u0026#39; datasg ENDS codesg SEGMENT START: mov ax, codesg mov ds, ax mov bx, 0 mov cx, 4 ; 外层循环，代表每一行，总共4行 s0: mov si, 0 mov cx, 3 ; 内层循环，代表每一行的前三个字符 s: mov al, [bx + si] and al, 11011111b mov [bx + si], al inc si loop s ; 内层循环结束 add bx, 16 loop s0 ; 外层循环结束 codesg ENDS END START 这里的问题出现在，内层和外层都使用的是 cx 寄存器计数（就相当于 C++ 中，你两层循环都用 i 来迭代，这个肯定不行）。由于汇编中 loop 函数只能用 cx 寄存器计数实现，解决方法是，在进入内部的一个循环时，先将 cx 的数值暂存起来，等到里面的循环结束了之后，再恢复，这个借用 dx 寄存器来实现暂存，于是代码变成了这样：\nASSUME CS:codesg, DS:datasg datasg SEGMENT db \u0026#39;ibm \u0026#39; db \u0026#39;dec \u0026#39; db \u0026#39;dos \u0026#39; db \u0026#39;vax \u0026#39; datasg ENDS codesg SEGMENT START: mov ax, codesg mov ds, ax mov bx, 0 mov cx, 4 s0: mov dx, cx ; 使用 dx 寄存器暂存 cx 的值，用于后面的恢复 mov si, 0 mov cx, 3 s: mov al, [bx + si] and al, 11011111b mov [bx + si], al inc si loop s add bx, 16 mov cs,dx ; 恢复 cx 的值 loop s0 codesg ENDS END START 这里的问题又在于，不能想着暂存时，使用寄存器，因为寄存器的数量是有限的。这个时候，我们可以想到使用内存来实现，并且在需要暂存数据的时候，我们都应该使用栈。于是，程序可以做进一步的改进。\nASSUME CS:codesg, DS:datasg, SS:stacksg datasg SEGMENT db \u0026#39;ibm \u0026#39; db \u0026#39;dec \u0026#39; db \u0026#39;dos \u0026#39; db \u0026#39;vax \u0026#39; datasg ENDS stacksg SEGMENT dw 0, 0, 0, 0, 0, 0, 0, 0 stacksg ENDS codesg SEGMENT START: mov ax, stacksg mov ss, ax mov sp, 16 mov ax, codesg mov ds, ax mov bx, 0 mov cx, 4 s0: push cx ; 将外层循环的计数器 cx 压栈 mov si, 0 mov cx, 3 ; cx 设置为内层循环的次数 s: mov al, [bx + si] and al, 11011111b mov [bx + si], al inc si loop s add bx, 16 pop cx ; 弹出外层循环的计数器 cx, 恢复 cx loop s0 mov ax, 4c00h int 21h codesg ENDS END START ","permalink":"http://localhost:1313/posts/assembly/memory_location/","summary":"使用间接寻址访问内存中的指令 [0] 表示访问内存地址为 0 的位置，[bx] 表示访问内存地址为 bx 寄存器值的位置。 ; 从内存地址为 0x1000 的位置读取一个字节 mov bx, 0x1000 ; 将 0x1000 存入 bx 寄存器 mov al, [bx] ; 从内存地址为 bx 的位置读取一个字节，存入 al 寄存器 使用 and 和 or 实现内存定位 and 指令：按位进行与运算，可以将相应位设为0，","title":"内存访问"},{"content":"ESP8266 ESP8266 利用 WiFi 联网时有三种工作模式。\nStation 模式：工作在 Station 模式下的 ESP8266 就像是一个接收机一样，它可以接收来自无线路由器发出的信号。ESP8266 模块通过路由器连接互联网，手机或电脑通过互联网实现对设备的远程控制。 SoftAP 模式：无线接入点的简称，ESP8266 模块作为热点，实现手机或电脑直接与模块通信，实现局域网无线控制。 Station + SoftAP 模式：两种模式共存，既可以通过路由器连接到互联网，也可以作为 WiFi 热点，使其他设备连接到模块，实现广域网与局域网的无缝切换。 相关参考 构建过程 + 核心函数：\n基于 PlatformIO 平台玩转 NodeMCU 入门篇 | 匠心博客 (zhaomenghuan.js.org)\n","permalink":"http://localhost:1313/posts/embedded_system/nodemcu/nodemcu/","summary":"ESP8266 ESP8266 利用 WiFi 联网时有三种工作模式。 Station 模式：工作在 Station 模式下的 ESP8266 就像是一个接收机一样，它可以接收来自无线路由器发出的信号。ESP8266 模块通过路由器连接互联网，手机或电脑通过互联网实现对设备的远程控制。 SoftAP 模式：无线接入点的简称，ESP8266 模块作为热点，实现手机或电脑直接与模块通信","title":"NodeMCU 简介"},{"content":"1. command ‘platformio-ide.build‘ not found 解决：关闭 Vscode 再打开就好了~\n2. PlatformIO串口显示乱码 解决：串口监视器和单片机波特率不一致\n[env:nodemcuv2] platform = espressif8266 board = nodemcuv2 framework = esp8266-rtos-sdk monitor_speed = 74880 ; 监视器波特率设置 monitor_port = COM3 ; 监视器端口设置，设置为连接的串口端口 3. PlatformIO串口显示开头乱码 原因：很有可能是因为你之前烧写的程序没关，或是因为芯片自身不稳定，但只要它可以显示出你想显示的就可以。\n","permalink":"http://localhost:1313/posts/embedded_system/nodemcu/problem_nodemcu/","summary":"1. command ‘platformio-ide.build‘ not found 解决：关闭 Vscode 再打开就好了~ 2. PlatformIO串口显示乱码 解决：串口监视器和单片机波特率不一致 [env:nodemcuv2] platform = espressif8266 board = nodemcuv2 framework = esp8266-rtos-sdk monitor_speed = 74880 ; 监视器波特率设置 monitor_port = COM3 ; 监视器端口设置，设置为连接的串口端口 3. PlatformIO串口显示开头乱码 原因：","title":"NodeMCU 编程遇到的问题"},{"content":"嵌入式命令 查看已经安装的驱动：sudo dmesg\n查看安装的串口设备：ls -l /dev/ttyS*\n查看安装的USB转串口设备：ls -l /dev/ttyS*\n查看系统日志关于串口设备的信息：dmesg | grep ttyS\n查看 ttyS0 驱动的安装时间：ls -l /dev/ttyS0\nWindows 下查看端口命令 通用方法，Win + X，选择设备管理器，查看 COM 端口，也可点击属性信息查看\nPlatformIO Vscode 开发，点击小图标，然后输入命令：pio device list\n","permalink":"http://localhost:1313/posts/embedded_system/nodemcu/common_commands/","summary":"嵌入式命令 查看已经安装的驱动：sudo dmesg 查看安装的串口设备：ls -l /dev/ttyS* 查看安装的USB转串口设备：ls -l /dev/ttyS* 查看系统日志关于串口设备的信息：dmesg | grep ttyS 查看 ttyS0 驱动的安装时间：ls -l /dev/ttyS0 Windows 下查看端口命令 通用方法，Win + X，选择设备管理器，查看 COM 端口，也可点击属性信息查看 PlatformIO Vscode 开发，点","title":"嵌入式常用命令汇总"},{"content":"安装 ros2 control 安装 安装 ros2 control，humble 替换为你使用的版本\nsudo apt install ros-humble-ros2-control sudo apt install ros-humble-ros2-controllers 使用 RosTeamWS ROS工作区模板 能够快速地创建特定 ros 功能包，提供模板功能\nhttps://rtw.stoglrobotics.de/master/index.html\nros2 安装 sudo apt install ros-humble-desktop https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html\nignition gazebo 安装 ignition 为新一代的模拟题，替换了之前使用的 gazebo\nsudo wget https://packages.osrfoundation.org/gazebo.gpg -O /usr/share/keyrings/pkgs-osrf-archive-keyring.gpg echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/pkgs-osrf-archive-keyring.gpg] http://packages.osrfoundation.org/gazebo/ubuntu-stable $(lsb_release -cs) main\u0026#34; | sudo tee /etc/apt/sources.list.d/gazebo-stable.list \u0026gt; /dev/null sudo apt-get update sudo apt-get install gz-harmonic https://staging.gazebosim.org/docs/harmonic/install_ubuntu\n安装 python2 版本和 python3 版本的numpy sudo apt-get install python-numpy # python2 numpy sudo apt-get install python3-numpy # python3 numpy ","permalink":"http://localhost:1313/posts/robot/ros/ros_about/","summary":"安装 ros2 control 安装 安装 ros2 control，humble 替换为你使用的版本 sudo apt install ros-humble-ros2-control sudo apt install ros-humble-ros2-controllers 使用 RosTeamWS ROS工作区模板 能够快速地创建特定 ros 功能包，提供模板功能 https://rtw.stoglrobotics.de/master/index.html ros2 安装 sudo apt install ros-humble-desktop https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html ignition gazebo 安装 ignition 为新一代的模拟题，替换了之前使用的 gazebo sudo wget https://packages.osrfoundation.org/gazebo.gpg -O /usr/share/keyrings/pkgs-osrf-archive-keyring.gpg echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/pkgs-osrf-archive-keyring.gpg] http://packages.osrfoundation.org/gazebo/ubuntu-stable $(lsb_release -cs) main\u0026#34; | sudo tee /etc/apt/sources.list.d/gazebo-stable.list \u0026gt; /dev/null sudo apt-get update sudo apt-get install gz-harmonic https://staging.gazebosim.org/docs/harmonic/install_ubuntu 安装 python2 版本和 python3 版本","title":"ros 相关的安装"},{"content":"\rDawn Journey\r在黎明的微光中，我们踏上了一场绚丽的旅程\r👉友链格式\r名称： Dawn Journey 网址： https://lidianzhong.gitee.io/ 图标： https://lidianzhong.gitee.io/img/Q.gif 描述： 在黎明的微光中，我们踏上了一场绚丽的旅程 ","permalink":"http://localhost:1313/links/","summary":"Dawn Journey 在黎明的微光中，我们踏上了一场绚丽的旅程 👉友链格式 名称： Dawn Journey 网址： https://lidianzhong.gitee.io/ 图标： https://lidianzhong.gitee.io/img/Q.gif 描述： 在黎明的微光中，我们踏上了一场绚丽的旅程","title":"🤝友链"},{"content":"Git 命令汇总 1. 分支相关 1.1 查看当前分支\ngit branch 1.2 创建一个新分支并切换到这个分支\ngit checkout -b dev\t# 创建新分支 dev 并切换到它 1.3 切换到某个分支\ngit checkout test\t# 切换到 test 分支 1.4 删除分支\ngit branch -d test\t# 删除 test 分支，如果分支没有被合并，使用 -D 参数强制删除 1.5 重命名分支\ngit branch -m \u0026lt;old_branch_name\u0026gt; \u0026lt;new_branch_name\u0026gt; 2. 撤销相关 2.1 撤销最近的一次提交\ngit reset --hard HEAD~1\t# 撤销最近的一次提交 ","permalink":"http://localhost:1313/posts/tools/git/git-command-overall/","summary":"Git 命令汇总 1. 分支相关 1.1 查看当前分支 git branch 1.2 创建一个新分支并切换到这个分支 git checkout -b dev # 创建新分支 dev 并切换到它 1.3 切换到某个分支 git checkout test # 切换到 test 分支 1.4 删除分支 git branch -d test # 删除 test 分支，如果分支没有被合并，使用 -D 参数强制删除 1.5 重命名分支 git branch -m \u0026lt;old_branch_name\u0026gt; \u0026lt;new_branch_name\u0026gt; 2. 撤销相关 2.1 撤销最近的一次提交 git reset --hard HEAD~1 # 撤销最近的","title":"Git 命令汇总"},{"content":" 在我们想要将本地的代码提交到Github远程仓库时，会因为网络问题，拉取失败。\n解决Git提交拉取时的网络问题 查询以下网址对应的DNS服务器地址: DNS查询工具 github.com github.global.ssl.fastly.net assets-cdn.github.com 修改 hosts 文件 20.205.243.166 github.com 66.220.148.145 github.global.ssl.fastly.net 185.199.111.153 assets-cdn.github.com # https://tool.chinaz.com/dns/github.com # https://tool.chinaz.com/dns/github.global.ssl.fastly.net # https://tool.chinaz.com/dns/assets-cdn.github.com 解决 Git clone 时的网络问题 加个fast：https://github.com/ 改为 https://githubfast.com/ 使用镜像仓库：Github镜像仓库 ","permalink":"http://localhost:1313/posts/tools/git/solve-git-slow-problem/","summary":"在我们想要将本地的代码提交到Github远程仓库时，会因为网络问题，拉取失败。 解决Git提交拉取时的网络问题 查询以下网址对应的DNS服务器地址: DNS查询工具 github.com github.global.ssl.fastly.net assets-cdn.github.com 修改 hosts 文件 20.205.243.166 github.com 66.220.148.145 github.global.ssl.fastly.net 185.199.111.153 assets-cdn.github.com # https://tool.chinaz.com/dns/github.com # https://tool.chinaz.com/dns/github.global.ssl.fastly.net # https://tool.chinaz.com/dns/assets-cdn.github.com 解决 Git clone 时的网络问题 加个fast：https://github.com/ 改为 https://githubfast.com/ 使用","title":"解决Git同步访问慢的问题"},{"content":" 后续开发的算法，最终结果都是生成发送给这12个关节电机的命令\n四足机器人的动力系统 1. 永磁同步电机（PMSM） 通过控制定子上三个线圈的电流，可以控制电机的力矩和角度。这种控制方法叫做矢量控制（FOC）。\n2. 关节电机的混合控制 关节电机的内部，已经封装了电机底层的控制算法。作为用户，只要给关节电机发送相关的命令，电机就能完成从接收命令到关节力矩输出的工作。\n控制指令有五个：前馈力矩、期望角度位置、期望角速度、位置刚度、速度刚度（阻尼）\n3. 关节电机的命令下发 通过 RS485 接口进行通信，用上位机控制需要使用 USB 转 RS485 转接器。\n4. 使用Python代码控制电机 指定七个参数，分别为id、mode和前面说的5个控制指令（T、W、Pos、K_P、K_W），作为结构体数据。结构体数据先要依据通信协议将数据编码为电机能够接收的格式，然后就能给电机发送命令。电机返回的数据也要通过解码再进行下一步的数据处理。\n电机只有在接收到命令时才会返回当前自身状态，所以如果只是让电机持续运转，那么不需要持续发同一条命令，为了时刻检测电机状态，才需要持续发送命令。\n用结构体中的mode参数来控制电机的控制模式。\n位置模式：电机的输出轴稳定在一个固定的位置；\n速度模式：电机稳定在一个固定的速度，\n阻尼模式：在被外力旋转时，会产生一个抗阻力矩。方向与旋转方向相反，大小与旋转速度成正比；力矩模式，电机输出一个恒定力矩；\n零力矩模式：保持力矩为0，转动输出轴的阻力会明显小于未开机时的阻力；\n混合模式（最常用）：发送前馈力矩、目标角度、目标角速度混合控制。\n5. 移植到其他上位机 根据电机发送的报文格式，通过 RS-485 协议标准，进行串口通信\n","permalink":"http://localhost:1313/posts/robot/robot_book/2_guan_jie_dian_ji/","summary":"后续开发的算法，最终结果都是生成发送给这12个关节电机的命令 四足机器人的动力系统 1. 永磁同步电机（PMSM） 通过控制定子上三个线圈的电流，可以控制电机的力矩和角度。这种控制方法叫做矢量控制（FOC）。 2. 关节电机的混合控制 关节电机的内部，已经封装了电机底层的控制算法。作为用户，只要给","title":"四足机器人关节电机"},{"content":"\n关于我\rDawn Journey\r在黎明的微光中，我们踏上了一场绚丽的旅程\r一首诗\r轮台东门送君去，去时雪满天山路。\r峰回路转不见君，雪上空留马行处。\r本站建于 2024 年 4 月 1 日\n","permalink":"http://localhost:1313/about/","summary":"关于我 Dawn Journey 在黎明的微光中，我们踏上了一场绚丽的旅程 一首诗 轮台东门送君去，去时雪满天山路。 峰回路转不见君，雪上空留马行处。 本站建于 2024 年 4 月 1 日","title":"🙋🏻‍♂️关于"}]