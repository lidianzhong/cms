[{"content":"__init__.py 的作用 用于告诉 Python 解释器，该目录是一个包，而不仅仅是一个普通的目录。这样你就可以使用 import 来导入目录中的模块\n同时在 init.py 文件中你也可以做一些必要的设置、定义一些变量等等。\n","permalink":"https://lidianzhong.gitee.io/posts/python/grammar/","summary":"__init__.py 的作用 用于告诉 Python 解释器，该目录是一个包，而不仅仅是一个普通的目录。这样你就可以使用 import 来导入目录中的模块 同时在 init.py 文件中你也可以做一些必要的设置、定义一些变量等等。","title":"python 语法"},{"content":"go2 高层运动 订阅：/sportmodestate ，类型为 unitree_go::msg::SportModeState\n发布：api/sport/request，类型为 unitree_api::msg::Request\nunitree_go::msg::SportModeState\nTimeSpec stamp(); uint32_t errorCode(); //错误代码 IMU imuState(); //IMU状态 uint8_t mode(); //运动模式 /* 运动模式 0. idle, default stand 1. balanceStand 2. pose 3. locomotion 4. reserve 5. lieDown 6. jointLock 7. damping 8. recoveryStand 9. reserve 10. sit 11. frontFlip 12. frontJump 13. frontPounc */ float progress(); //是否动作执行状态：0. dance false; 1. dance true uint8_t gaitType(); //步态类型 /* 步态类型 0.idle 1.trot 2.run 3.climb stair 4.forwardDownStair 9.adjust */ float footRaiseHeight(); //抬腿高度 std::array\u0026lt;float, 3\u0026gt; position(); //三维位置 float bodyHeight(); //机体高度 std::array\u0026lt;float, 3\u0026gt; velocity(); //三维速度 float yawSpeed(); //偏航速度 std::array\u0026lt;float, 4\u0026gt; rangeObstacle(); //障碍物距离 std::array\u0026lt;int16_t, 4\u0026gt; footForce(); //四个足端力 std::array\u0026lt;float, 12\u0026gt; footPositionBody(); //足端相对于机体的位置 std::array\u0026lt;float, 12\u0026gt; footSpeedBody(); //足端相对与机体的速度 std::array\u0026lt;PathPoint, 10\u0026gt; pathPoints(); //当前跟踪的路径点 unitree_api::msg::Request\nRequestHeader header string parameter uint8[] binary 对 unitree_api::msg::Request 中的 string parameter 参数进行解析：\n消息案例：\nParameter: [ { \u0026#34;t_from_start\u0026#34;: 0.0, \u0026#34;vx\u0026#34;:0.38878634572029114, \u0026#34;vy\u0026#34;:0.0, \u0026#34;vyaw\u0026#34;:0.0, \u0026#34;x\u0026#34;:0.3143965005874634, \u0026#34;y\u0026#34;:0.0, \u0026#34;yaw\u0026#34;:0.0 } , { \u0026#34;t_from_start\u0026#34;: 0.20000000298023224, \u0026#34;vx\u0026#34;:0.35545676946640015, \u0026#34;vy\u0026#34;:0.0, \u0026#34;vyaw\u0026#34;:0.0, \u0026#34;x\u0026#34;:0.3516397178173065, \u0026#34;y\u0026#34;:0.0, \u0026#34;yaw\u0026#34;:0.0 } , { \u0026#34;t_from_start\u0026#34;: 0.4000000059604645, \u0026#34;vx\u0026#34;:0.31857556104660034, \u0026#34;vy\u0026#34;:0.0, \u0026#34;vyaw\u0026#34;:0.0, \u0026#34;x\u0026#34;:0.3853694498538971, \u0026#34;y\u0026#34;:0.0, \u0026#34;yaw\u0026#34;:0.0 } ....... ] 消息含义解释：\n\u0026quot;t_from_start\u0026quot;: 从路径开始到达此点所需的时间。 \u0026quot;vx\u0026quot;: 在此点的x方向上的期望速度。 \u0026quot;vy\u0026quot;: 在此点的y方向上的期望速度。 \u0026quot;vyaw\u0026quot;: 在此点的期望偏航速度。 \u0026quot;x\u0026quot;: 此点的x坐标。 \u0026quot;y\u0026quot;: 此点的y坐标。 \u0026quot;yaw\u0026quot;: 此点的偏航角。 ","permalink":"https://lidianzhong.gitee.io/posts/robot/draft/plan/","summary":"go2 高层运动 订阅：/sportmodestate ，类型为 unitree_go::msg::SportModeState 发布：api/sport/request，类型为 unitree_api::msg::Request unitree_go::msg::SportModeState TimeSpec stamp(); uint32_t errorCode(); //错误代码 IMU imuState(); //IMU状态 uint8_t mode(); //运动模式 /* 运动模式 0. idle, default stand 1. balanceStand 2. pose 3. locomotion 4. reserve 5. lieDown 6. jointLock 7. damping 8. recoveryStand 9. reserve 10. sit 11. frontFlip 12. frontJump 13. frontPounc */ float progress(); //是否动作执行状态：0. dance false; 1. dance true uint8_t gaitType(); /","title":"go2 控制器方案"},{"content":"安装汇总 安装 ros2 control 安装 安装 ros2 control，humble 替换为你使用的版本\nsudo apt install ros-humble-ros2-control sudo apt install ros-humble-ros2-controllers 使用 RosTeamWS ROS工作区模板 能够快速地创建特定 ros 功能包，提供模板功能\nhttps://rtw.stoglrobotics.de/master/index.html\nros2 安装 sudo apt install ros-humble-desktop https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html\nignition gazebo 安装 ignition 为新一代的模拟题，替换了之前使用的 gazebo\nsudo wget https://packages.osrfoundation.org/gazebo.gpg -O /usr/share/keyrings/pkgs-osrf-archive-keyring.gpg echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/pkgs-osrf-archive-keyring.gpg] http://packages.osrfoundation.org/gazebo/ubuntu-stable $(lsb_release -cs) main\u0026#34; | sudo tee /etc/apt/sources.list.d/gazebo-stable.list \u0026gt; /dev/null sudo apt-get update sudo apt-get install gz-harmonic https://staging.gazebosim.org/docs/harmonic/install_ubuntu\n安装 python2 版本和 python3 版本的numpy sudo apt-get install python-numpy # python2 numpy sudo apt-get install python3-numpy # python3 numpy ","permalink":"https://lidianzhong.gitee.io/posts/robot/draft/install_draft/","summary":"安装汇总 安装 ros2 control 安装 安装 ros2 control，humble 替换为你使用的版本 sudo apt install ros-humble-ros2-control sudo apt install ros-humble-ros2-controllers 使用 RosTeamWS ROS工作区模板 能够快速地创建特定 ros 功能包，提供模板功能 https://rtw.stoglrobotics.de/master/index.html ros2 安装 sudo apt install ros-humble-desktop https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html ignition gazebo 安装 ignition 为新一代的模拟题，替换了之前使用的 gazebo sudo wget https://packages.osrfoundation.org/gazebo.gpg -O /usr/share/keyrings/pkgs-osrf-archive-keyring.gpg echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/pkgs-osrf-archive-keyring.gpg] http://packages.osrfoundation.org/gazebo/ubuntu-stable $(lsb_release -cs) main\u0026#34; | sudo tee /etc/apt/sources.list.d/gazebo-stable.list \u0026gt; /dev/null sudo apt-get update sudo apt-get install gz-harmonic https://staging.gazebosim.org/docs/harmonic/install_ubuntu 安装 python2 版本","title":"安装汇总"},{"content":" 介绍目前全球知名的四足机器人研究组织和相关的机器人和四足机器人总体概述\n四足机器人发展现状 波士顿动力公司（Boston Dynamics） 相关机器人：Altas、Stretch、Spot\n麻省理工学院 Biomimetic Robotics Lab 相关机器人：MIT Cheetah、MIT Mini Cheetah\n苏黎世联邦理工学院（ETH Zurich） 相关机器人：ANYmal\n宇树科技（Unitree Robotics）（国内） 相关机器人：Laikago、Aliengo、A1、Go1、Go2\n四足机器人的组成 动力系统 + 控制系统 + 通信系统 + 能源系统\n动力系统：核心是机器人关节电机，需要能够对关节力矩和角度进行精确控制。\n控制系统： 重点是控制算法，比如规划器和运动控制器，能够根据目标路径计算出各个关节需要执行的命令\n通信系统：各个关节电机、传感器、遥控手柄的通信\n能源系统：使用电池或者外部直流电源进行供电\n","permalink":"https://lidianzhong.gitee.io/posts/robot/robot_book/1_overview/","summary":"介绍目前全球知名的四足机器人研究组织和相关的机器人和四足机器人总体概述 四足机器人发展现状 波士顿动力公司（Boston Dynamics） 相关机器人：Altas、Stretch、Spot 麻省理工学院 Biomimetic Robotics Lab 相关机器人：MIT Cheetah、MIT Mini Cheetah 苏黎世联邦理工学院（ETH Zuric","title":"四足机器人概述"},{"content":"ROS与Gazebo ROS 中将每一个进程视作一个节点（Node），节点之间的通信方式依靠：话题（Topic）、服务（Service）、参数（Parameter）。\n控制器（Controller）与仿真（Gazebo）就是两个节点，利用 topic通信。\n过程是：控制器从Gazebo读取机器人各个关节角度、角速度、IMU等数值，然后计算出控制量，如目标力矩、目标关节角度等发送给Gazebo。\n面向对象设计 面向对象的程序设计的三大特性为：封装、继承、多态。\n想象以下的场景：有一个控制器，想要它既可以与仿真环境Gazebo交互，也可以和实际的机器人交互。如何实现？\n封装：将控制器与ROS交互接口的收发功能进行封装，用类中的一个方法加以实现。\n继承：针对仿真模型和真实机器人的两个接口类，IOROS类和IOSDK类。它们用不同的方法完成同一个任务，即收发数据。因此他们有相同的共性，我们可以将这个共性提取到IOInterface类，都用到的函数设定为纯虚函数。\n多态：现在有了两个接口，通过将父类（IOInterface）的指针赋值为IOROS或IOSDK指针的值，可以方便地完成控制器在仿真平台到真实机器人的切换。\n有限状态机 有限状态机不是一个真实的硬件，而是抽象的概念。利用有限状态机可以实现控制器中对各个状态的切换。比如从阻尼模式切换到站立模式。\n有限状态机有五种状态（阻尼模式、固定站立、自由站立等），两种任务。任务一是重复当前运行状态（即重复执行当前状态的run函数），任务二是切换状态。\n实现：让机器人站起来 机器人的关节控制 前面说了如何发送命令给单个电机，以控制电机或读取状态，现在考虑给机器人的12个电机发送电机命令和接收状态。\n相关的类是 FSMState.h，它是有限状态机四个状态的基类，每个状态继承了下面变量：\nCtrlComponents *_ctrlComp;\t// 包含大多数控制所需的类与状态变量 LowlevelCmd *_lowCmd;\t// 发送给各个电机的命令 LowlevelState *_lowState;\t// 从各个电机接收的状态 四足机器人有四条腿，同时每个腿有三个关节。关节顺序是这样定义的：\n每一条腿，自上而下的三个关节为机身关节、大腿关节、小腿关节，顺序分别为 0、1、2。 四条腿，按照右前腿、左前腿、右后腿、左右腿的顺序排列。 0:0 号腿 0 号关节，即右前腿机身关节 1:0 号腿 1 号关节，即右前腿大腿关节 2:0 号腿 2 号关节，即右前腿小腿关节 3:1 号腿 0 号关节，即左前腿机身关节 4:1 号腿 1 号关节，即左前腿大腿关节 5:1 号腿 2 号关节，即左前腿小腿关节 6:2 号腿 0 号关节，即右后腿机身关节 7:2 号腿 1 号关节，即右后腿大腿关节 8:2 号腿 2 号关节，即右后腿小腿关节 9:3 号腿 0 号关节，即左后腿机身关节 10:3 号腿 1 号关节，即左后腿大腿关节 11:3 号腿 2 号关节，即左后腿小腿关节 机器人的阻尼模式 出于安全考虑，一般机器人在开机时默认进入阻尼模式（Passive）。\n阻尼模式的代码src/FSM/State_Passive.cpp：\nvoid State_Passive::enter(){ if(_ctrlComp-\u0026gt;ctrlPlatform == CtrlPlatform::GAZEBO){ for(int i=0; i\u0026lt;12; i++){ _lowCmd-\u0026gt;motorCmd[i].mode = 10; _lowCmd-\u0026gt;motorCmd[i].q = 0; _lowCmd-\u0026gt;motorCmd[i].dq = 0; _lowCmd-\u0026gt;motorCmd[i].Kp = 0; _lowCmd-\u0026gt;motorCmd[i].Kd = 8; _lowCmd-\u0026gt;motorCmd[i].tau = 0; } } else if(_ctrlComp-\u0026gt;ctrlPlatform == CtrlPlatform::REALROBOT){ for(int i=0; i\u0026lt;12; i++){ ...... } } _ctrlComp-\u0026gt;setAllSwing(); } void State_Passive::run(){ } void State_Passive::exit(){ } 可以看到，代码对在仿真平台和真实机器人进行了不同的设定。各个参数的设置放置在了 函数enter中，意味着只有在有限状态机进入阻尼模式时，LowLevelCmd 才修改一次。而 run 和 exit 均为空函数，说明不进行其它操作。但是有限状态机在运行时会不停地发送LowLevelCmd给电机，所以机器人会持续收到阻尼模式的命令。\n在有限状态机中，添加了自动保护功能。checkSafty 函数进行了机身姿态的判断。当checkSafty 返回 false 时，会让机器人的所有关节进入阻尼模式。\n机器人各个关节的坐标系与零角度点 机器人的每个关节需要一个坐标系和零角度点来确定位置和角度\n机器人上所有的坐标系都是右手系，且互相平行。坐标系的 x 轴朝向机器人的前方，y 轴朝向机器人的左侧，z 轴竖直向上。\n机身关节的旋转轴为 x 轴，大腿关节和小腿关节为 y 轴，旋转正方向符合右手定则，使用弧度制。\n这样就可以用数值来表示一个特定的关节状态了。比如机器人站立的状态就可以表示为：\n机身关节：0.00 大腿关节：0.67 小腿关节：-1.30 于是我们就可以在代码中设定目标关节角度：\nfloat_targetPos[12] = {0.0, 0.67, -1.3, 0.0, 0.67, -1.3, 0.0, 0.67, -1.3, 0.0, 0.67, -1.3}; 机器人的固定站立模式 知道了机器人的目标角度，如何实现机器人的固定站立呢？\n对函数 enter、run、exit进行考虑：\n在 enter 函数中，首先将每个关节的期望值设定好，然后再更新最初姿态的变量\nvoid State_FixedStand::enter(){ for(int i=0; i\u0026lt;4; i++){ if(_ctrlComp-\u0026gt;ctrlPlatform == CtrlPlatform::GAZEBO){ _lowCmd-\u0026gt;setSimStanceGain(i);\t// 设置关节期望值 } else if(_ctrlComp-\u0026gt;ctrlPlatform == CtrlPlatform::REALROBOT){ _lowCmd-\u0026gt;setRealStanceGain(i); } _lowCmd-\u0026gt;setZeroDq(i);\t// 设置关节期望值 _lowCmd-\u0026gt;setZeroTau(i);\t// 设置关节期望值 } for(int i=0; i\u0026lt;12; i++){ _lowCmd-\u0026gt;motorCmd[i].q = _lowState-\u0026gt;motorState[i].q; _startPos[i] = _lowState-\u0026gt;motorState[i].q;\t// 设定初始姿态 } _ctrlComp-\u0026gt;setAllStance(); } 在 run 函数中，使用线性插值来完成从最初状态到目标姿态的过渡，每运行一次越靠近目标姿态\nvoid State_FixedStand::run(){ _percent += (float)1/_duration; _percent = _percent \u0026gt; 1 ? 1 : _percent; for(int j=0; j\u0026lt;12; j++){ _lowCmd-\u0026gt;motorCmd[j].q = (1 - _percent)*_startPos[j] + _percent*_targetPos[j]; } } 在 exit 函数中，将 _percent 设置为 0，这样再次切换到站立模式，才能正常运行。\n","permalink":"https://lidianzhong.gitee.io/posts/robot/robot_book/3_ji_qi_ren_fang_zhen_yu_kong_zhi_kuang_jia/","summary":"ROS与Gazebo ROS 中将每一个进程视作一个节点（Node），节点之间的通信方式依靠：话题（Topic）、服务（Service）、参数（Parameter）。 控制器（Controller）与仿真（Gazebo）就是两个节点，利用 topic通信。 过程是：控制器从Gazebo读取机器","title":"机器人仿真与控制框架"},{"content":"出现 LF will be replaced by CRLF in ****** 解决方法：git config core.autocrlf false\n","permalink":"https://lidianzhong.gitee.io/posts/ubuntu/problem/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/","summary":"出现 LF will be replaced by CRLF in ****** 解决方法：git config core.autocrlf false","title":"字符编码问题"},{"content":"什么是 Representation Learning（表征学习） 机器学习算法的work与否不仅仅取决于算法的正确选用，也取决于数据的质量和有效的表示（representation）。针对不同类型的数据（text，image，video），不同的表示可能会导致有效信息的缺失或是曝露，这决定了算法能否有效地解决问题。表征学习的目的是对复杂的原始数据化繁为简，把原始数据的无效的或者冗余的信息剔除，把有效信息进行提炼，形成特征（feature）。\n特征提取可以人为地手工处理，也可以借助特定的算法自动提取。Roughly Speaking， 前者为特征工程，后者为表征学习（Representation Learning）。如果数据量较小，我们可以根据自身的经验和先验知识，人为地设计出合适的特征，用作下游的任务，比如表征学习同样在人工智能领域有着相当重要的地位。 我们已经知道人类的信息处理过程与长期记忆和短期记忆密切相关。短期记忆是短期存储的记忆，长期记忆就是我们大脑中长期存储的知识，就像在图书馆中存储的海量文献。根据这个简单的信息处理模型，再加上计算机更快的计算速度和海量的存储空间，人工智能应该比人类更为强大才是。但至少到目前，我们看到的情况并非如此。这其中一个重要的原因就是我们还未能破解人类大脑究竟是如何对数据进行编码，和对知识进行存储的。处理外界信息的第一步就是要将其编码，投影到某一空间。比如说，当人类仅需要几个例子就可以区分猫和狗的不同，而机器却需要大量数据训练时，我们不由得想要探寻：人类是如何对图像进行编码的？他提取了哪些特征可以通过少量样本进行学习？为什么人类学习的知识更灵活，可以在更多方面应用，而机器学习的模型通用性往往很差？这正是表征学习探索的目标：寻找对数据更好的表示方式。（机器学习的目的就是学习物质的有限个特征，而这些特征都要从数据里来。数据如何更够更好地反应我们需要的特征，让数据能够更多更准确地得到物质的特征，这个工作可以由人工处理完成，也可以通过自动化的表征学习来完成）。\n一般来说，数据该如何进行表示能收到更好的效果，是各个数据更加独立？还是其它？\n在单个任务中，选用什么样的数据表示更好，比如在图像中，设计的HSV就比RGB一般效果要好\n","permalink":"https://lidianzhong.gitee.io/posts/machinelearning/deeplearning/representationlearning/","summary":"什么是 Representation Learning（表征学习） 机器学习算法的work与否不仅仅取决于算法的正确选用，也取决于数据的质量和有效的表示（representation）。针对不同类型的数据（text，image，video），不同的表示可能会导致有效信息的缺失或是曝露，这决定了算法能否有效地解决","title":"Representation Learning"},{"content":"原因分析 使用 df -h 发现，根目录的挂载 / 点的磁盘空间满了，然后发现是 docker 的原因，占用空间太大\n解决方法 删除 docker Overlay2 中的部分内容\n具体执行 参考：记录一次docker Overlay2占用磁盘空间99%的清理过程 | Laravel China 社区 (learnku.com)\n","permalink":"https://lidianzhong.gitee.io/posts/ubuntu/problem/%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3/","summary":"原因分析 使用 df -h 发现，根目录的挂载 / 点的磁盘空间满了，然后发现是 docker 的原因，占用空间太大 解决方法 删除 docker Overlay2 中的部分内容 具体执行 参考：记录一次docker Overlay2占用磁盘空间99%的清理过程 | Laravel China 社区 (learnku.com)","title":"磁盘空间不足"},{"content":"","permalink":"https://lidianzhong.gitee.io/posts/tools/docker/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","summary":"","title":"常用命令"},{"content":"","permalink":"https://lidianzhong.gitee.io/posts/embedded_system/nodemcu/nodemcu_esp8266_%E5%85%A5%E9%97%A8/","summary":"","title":"NodeMCU + esp8266 入门"},{"content":"什么是潜变量 潜变量，潜在变量，与观测变量相对，意思是不可观测的随机变量。\n那么潜变量可以被推断出来吗？可以。通过数学模型依据观测得的数据可推断潜在变量。其中用潜在变量解释观测变量的数学模型称为潜变量模型。\n潜变量和现实一些因素是有关系的，测量这些因素表面上可行，实际上很困难，这些通常使用“隐变量（hidden variables）”来表示。另外一些情况下，一些抽象的概念也可以被理解为潜变量，比如分类，行为，心理状态，数据结构等等。\n潜变量有什么用呢？好处在于潜变量可以降低数据的维度，大量的观测变量通过处理变为潜变量用于表示深层次的概念。\n潜在空间（Latent Space） 一句话，潜在空间即数据的紧凑表示形式。\n这个空间中是对数据的压缩，其中就包含了数据的关键特征，其次维度较低，方便有效地表示了数据。\n如果要训练一个手写数字的训练集，数据就是数字的图像。而现在你有一个可以对数字进行分类的模型，那么这个模型就已经学到了每个数字的特征，从而能够对数字进行分类。\n那么从数据到模型学到特征的过程是“隐藏的”，也就是隐藏/潜在空间中的Latent的意思，“隐藏的”。\n深度学习就是学习数据的特征并简化数据表示，我们就是找能够做到这个的模型。\n为什么要进行数据压缩？ 为什么要把获得来的数据集压缩之后处理呢，直接用不行吗？\n原因是模型到后面需要重建压缩数据（也就是解码器），那么这个模型就需要做到：存储所有相关的信息，忽略噪声（即只关注数据最重要的特征）。这时数据压缩就有必要了——去掉无关的噪声信息，使得存储数据的关键特征。\n数据压缩后的这个“压缩状态”就是数据在潜在空间中的表示。\n为什么我们数据的维度降低会使相似的图像在空间中“更接近”？ 这其中要理解几个概念。\n什么是物质的相似？\n物质是客观存在的。不存在完全相同的两种物质。物质有无穷多的属性，特征是某一特定的属性。不存在所有特征都相同的两个物质。\n我们每次考虑观测对象是不是特定物质，是只考虑他们之间有限个特征。符合的特征越多，某个特征越接近，我们就说这个观测对象是不是越接近特定物质。\n所以我们说观测对象与特定物质的相似，是指只考虑有限个特征的情况下的。相同的特征数量越多，特征之间的距离越接近，就说两者越相似。\n举个实例\n首先，完全相同的两个椅子是不存在的。尽管可以质感，外观，图像都一样，但是位置特征不同，生产过程不同，总会有某一特征的的特征值不一样。\n如果我们看上面这张图片，我们或许会说，最左边的是椅子。这个过程是由人类感知形成的。可以确定，人类感知时，是考虑了很多不同特征的，形状特征、纹理特征等等。但也一定是只考虑有限个特征的，各个特征的偏向程度也是变化的、有影响的，比如上述我们会更忽视颜色特征的影响；也存在没有被考虑进来的特征，比如位置特征、朝向特征。\n于是乎，我们通过视觉感知实现了评价两个椅子的相似，或者实现了评价我们观察的内容是否是椅子。注意，不同人在不同时刻对视觉的感知程度是不相同的，有时候会更偏向某个特征。\n那么深度学习模型又如何完成视觉感知和物体识别呢？模型对某个观测对象的评价结果也不会像人一样会有偏向和受主观影响，模型会更多考虑物质的哪些特征呢？从感觉来说，对于评价是不是椅子这件事，主要考虑朝向特征的模型不是一个好模型，主要考虑颜色特征的模型不是一个好模型。\n由以上的分析，再对应于具体的模型训练过程，可以有如下启发：\n一个好的训练集，是指它能包含更多我们需要的特征，而且特征的特征值要尽可能准确，符合事实。 在训练过程中，要尽可能去除我们不需要的特征，或者削弱不重要特征的影响度。 对于不同的需求，我们对物质特征的侧重可能会有区别，因地制宜是个改进的办法。 这里进行数据降维，就是进行 去除不重要特征 的一种方法。\n通过数据降维来减轻或去除不重要特征的原因是上面？怎么做到的？\n怎么评判各个特征与相似性是相关还是不相关？\n可以做到对于不同的特征，我可以调整不同特征的影响因子，来做到定制化视觉感知\n如何让与相似性相关的特征保留下来，与相似性不相关的特征丢弃掉，怎么做的？\n如何实现数据从高维到低维的转换？\n","permalink":"https://lidianzhong.gitee.io/posts/machinelearning/machinelearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%BD%9C%E5%8F%98%E9%87%8F/","summary":"什么是潜变量 潜变量，潜在变量，与观测变量相对，意思是不可观测的随机变量。 那么潜变量可以被推断出来吗？可以。通过数学模型依据观测得的数据可推断潜在变量。其中用潜在变量解释观测变量的数学模型称为潜变量模型。 潜变量和现实一些因素是有关系的，测量这些因素表面上可行，实际上很困难，这些通常","title":"机器学习中的潜变量"},{"content":" 在 WSL2 中运行的有 http://localhost:1188/ 的服务，如何通过 Windows 宿主机进行访问？\n无需任何操作，直接在 Windows 中使用 http://localhost:1188/ 即可访问。\n这种情况只针对于使用的是 localhost\n使用 WSL 访问网络应用程序 | Microsoft Learn\n","permalink":"https://lidianzhong.gitee.io/posts/tools/wsl2/%E5%B1%80%E5%9F%9F%E7%BD%91%E8%AE%BF%E9%97%AEwsl2%E6%9C%8D%E5%8A%A1/","summary":"在 WSL2 中运行的有 http://localhost:1188/ 的服务，如何通过 Windows 宿主机进行访问？ 无需任何操作，直接在 Windows 中使用 http://localhost:1188/ 即可访问。 这种情况只针对于使用的是 localhost 使用 WSL 访问网络应用程序 | Microsoft Learn","title":"局域网访问WSL2服务"},{"content":"cuda 版本的问题 使用 nvidia-smi 命令显示的 cuda 版本表示支持最高的版本，并不是当前 cuda 的版本。\n查看当前 cuda 版本的命令是使用 nvcc -V 命令，显示的 cuda 版本。\ncuda 版本支持切换，主要是根据 PATH 中的指向来确定的\n切换 cuda 版本的命令如下\n# \u0026lt;version\u0026gt; 须切换的CUDA版本号 export PATH=/usr/local/cuda-\u0026lt;version\u0026gt;/bin${PATH:+:${PATH}} export LD_LIBRARY_PATH=/usr/local/cuda-\u0026lt;version\u0026gt;/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} [解決方案] conda 虚拟环境中 cuda不同版本進行切換（含Linux 和 Windows）_修改cuda版本-CSDN博客\nCUDA的正确安装/升级/重装/使用方式 - 知乎 (zhihu.com)\nubuntu下安装多版本cuda及版本切换教程_ubuntu切换cuda版本-CSDN博客\n","permalink":"https://lidianzhong.gitee.io/posts/ubuntu/py_environment/graphics_card/","summary":"cuda 版本的问题 使用 nvidia-smi 命令显示的 cuda 版本表示支持最高的版本，并不是当前 cuda 的版本。 查看当前 cuda 版本的命令是使用 nvcc -V 命令，显示的 cuda 版本。 cuda 版本支持切换，主要是根据 PATH 中的指向来确定的 切换 cuda 版本的命令如下 # \u0026lt;version\u0026gt; 须切换的CUDA版本号 export PATH=/usr/local/cuda-\u0026lt;version\u0026gt;/bin${PATH:+:${PATH}} export LD_LIBRARY_PATH=/usr/local/cuda-\u0026lt;version\u0026gt;/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}} [解決方案] conda 虚拟环境中 cuda不同版本進行切換（含Lin","title":"GPU 相关"},{"content":"卸载 Conda 环境 conda env remove --name myenv ","permalink":"https://lidianzhong.gitee.io/posts/ubuntu/py_environment/conda_command/","summary":"卸载 Conda 环境 conda env remove --name myenv","title":"Conda 常用命令汇总"},{"content":"安装问题 无法解析的服务器名称，Error code: Wsl/WININET_E_NAME_NOT_RESOLVED PS C:\\Users\\DianzhongLi\u0026gt; wsl --list --online 无法从“https://raw.githubusercontent.com/microsoft/WSL/master/distributions/DistributionInfo.json”中提取列表分发。无法解析服务器的名称或地址 Error code: Wsl/WININET_E_NAME_NOT_RESOLVED 解决方法：\n使用代理或者VPN 在 hosts 中指定 raw.githubusercontent.com 的对应ip 安装 WSL 报错 Error code: Wsl/WININET_E_NAME_NOT_RESOLVED 问题解决-CSDN博客\n屏幕缩放问题 使用 export GDK_DPI_SCALE=1.5 即可解决。\n其它解决方案：https://github.com/microsoft/wslg/issues/23\n不能显示中文字符 sudo mkdir /usr/share/fonts/win11 sudo ln -s /mnt/c/Windows/Fonts/* /usr/share/fonts/win11 ","permalink":"https://lidianzhong.gitee.io/posts/tools/wsl2/wsl2_problem/","summary":"安装问题 无法解析的服务器名称，Error code: Wsl/WININET_E_NAME_NOT_RESOLVED PS C:\\Users\\DianzhongLi\u0026gt; wsl --list --online 无法从“https://raw.githubusercontent.com/microsoft/WSL/master/distributions/DistributionInfo.json”中提取列表分发。无法解析服务器的名称","title":"Wsl2_problem"},{"content":"安装带图形化的 Ubuntu 使用 WSL 运行 Linux GUI 应用 | Microsoft Learn\n常用命令 在编辑器中启动 bashrc 文件：gnome-text-editor ~/.bashrc\nGNOME 桌面的文件管理器：nautilus\n多媒体播放器：vlc\nLinux 的 Google Chrome：google-chrome\nwsl2安装ssh Windows 11 安装 WSL2 并ssh远程连接 - 麦克斯的园丁 - 博客园 (cnblogs.com)\nwsl2安装 vscode 开始通过 WSL 使用 VS Code | Microsoft Learn\n卸载wsl2中的 vscode Uninstall Visual Studio Code\n","permalink":"https://lidianzhong.gitee.io/posts/tools/wsl2/wsl2_install/","summary":"安装带图形化的 Ubuntu 使用 WSL 运行 Linux GUI 应用 | Microsoft Learn 常用命令 在编辑器中启动 bashrc 文件：gnome-text-editor ~/.bashrc GNOME 桌面的文件管理器：nautilus 多媒体播放器：vlc Linux 的 Google Chrome：google-chrome wsl2安装ssh Windows 11 安装 WSL2 并ssh远程连接 - 麦克斯的园丁 - 博客园 (cnblogs.com) ws","title":"Wsl2_install"},{"content":"apt 清华源 配置地址：/etc/apt/sources.list\nubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n解压 tar.gz 文件 tar -xzvf filename.tar.gz 清华 conda 镜像 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/linux-64/ conda config --set show_channel_urls yes pip 清华源 临时使用：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package\n设为默认：pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple\npypi | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror\n根据 PID 来查看详细的进程信息 ps -f -p 2508841 Ubuntu进程管理查看当前GPU占用情况及哪个用户在使用 - DuanYongchun - 博客园 (cnblogs.com)\n","permalink":"https://lidianzhong.gitee.io/posts/ubuntu/common_command/common_command/","summary":"apt 清华源 配置地址：/etc/apt/sources.list ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror 解压 tar.gz 文件 tar -xzvf filename.tar.gz 清华 conda 镜像 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/linux-64/ conda config --set show_channel_urls yes pip 清华源 临时使用：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package 设为默认：pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple pypi | 镜像站使用帮助 | 清华大学开源软件","title":"Ubuntu 常用命令汇总"},{"content":"使用间接寻址访问内存中的指令 [0] 表示访问内存地址为 0 的位置，[bx] 表示访问内存地址为 bx 寄存器值的位置。\n; 从内存地址为 0x1000 的位置读取一个字节 mov bx, 0x1000 ; 将 0x1000 存入 bx 寄存器 mov al, [bx] ; 从内存地址为 bx 的位置读取一个字节，存入 al 寄存器 使用 and 和 or 实现内存定位 and 指令：按位进行与运算，可以将相应位设为0，其它位不变\nor 指令：按位或运行，可以将相应位设为1，其它位不变\nand al, 101111111B ;将al的第六位设为0 and al, 111111110B ;将al的第0位设为0 or al, 010000000B ; 将al的第六位设为1 实例：汇编中实现大小写转换 解决大小写转换问题：在汇编中不是考虑通过加减20H将大写转化为小写，或者小写转化为大写，而是采用大写第五位置0，小写第五位置1。比如 A 的二进制为 01000001，而小写 a 的二进制为 01100001。\nloop 函数如何实现：loop 指令是一个循环指令，它首先减少 CX 寄存器中的值，然后检查 CX 是否为零。如果 CX 不为零，则跳转到标签 s 处执行循环内的指令。如果 CX 为零，则程序继续执行下一条指令。\nASSUME CS:codesg, DS:datasg\t; 指定段寄存器的默认段值 datasg SEGMENT db \u0026#39;BaSiC\u0026#39;\t; 存储字符串，使用 \u0026#39;.......\u0026#39; 表示字符串 db \u0026#39;iNfOrMaTiOn\u0026#39; datasg ENDS codesg SEGMENT START: mov ax, datasg mov ds, ax mov bx, 0 mov cx, 5 s: mov al, [bx]\t; 循环 5 次，每次修改一个字母 and al, 11011111b\t; 这一步，将字母变成大写 mov [bx], al inc bx\t; bx 寄存器中的值加一 loop s mov bx, 5 mov cx, 11 s0: mov al, [bx] or al, 00100000b\t; 这一步，将字母变成小写 mov [bx], al inc bx loop s0 mov ax, 4c00h int 21h codesg ENDS END START [bx + idata] [bx + idata] 表明一个内存单元，它的偏移地址为 (bx) + idata(bx 中的数值加上 idata)。\n比如，mov ax,[bx + 200]，数学描述为 (ax) + ((ds) * 16 + (bx) + 200)\n这样，上面的大小写转换可以使用类似数组的方式实现\nASSUME CS:codesg, DS:datasg datasg SEGMENT db \u0026#39;BaSiC\u0026#39; db \u0026#39;iNfOrMaTiOn\u0026#39; datasg ENDS codesg SEGMENT START: mov ax, datasg mov ds, ax mov bx, 0 mov cx, 5 s: mov al, [bx] and al, 11011111b mov [bx], al mov [5 + bx], al inc bx loop s mov ax, 4c00h int 21h codesg ENDS END START SI 和 DI bx：在x86架构的汇编语言中，BX 寄存器通常用作地址寄存器，用于间接寻址。\nsi（Source Index）寄存器：通常用于指向源数据的内存地址。\ndi（Destination Index）寄存器：通常用于指向目标数据的内存地址。\n在一些情况下，它们也可被用于通用的寄存器。\n[bx + si] 和 [bx + di] 基址加索引寻址：\n[bx + si]：这种寻址方式表示的是以 bx 寄存器的值为基址，si 寄存器的值为偏移量的内存地址。例如，如果 bx 的值是 0x1000，si 的值是 0x0040，那么 [bx + si] 就表示的是内存地址 0x1040。 [bx + di]：这种寻址方式表示的是以 bx 寄存器的值为基址，di 寄存器的值为偏移量的内存地址。例如，如果 bx 的值是 0x2000，di 的值是 0x0080，那么 [bx + di] 就表示的是内存地址 0x2080。 [bx + si + idata] 和 [bx + si + idata] 基址加索引加位移寻址:\n[bx + si + idata]：这种寻址方式表示的是以 bx 寄存器的值为基址，si 寄存器的值为索引，idata 为一个立即数偏移量的内存地址。例如，如果 bx 的值是 0x1000，si 的值是 0x0040，idata 的值是 0x0002，那么 [bx + si + idata] 就表示的是内存地址 0x1042。 [bx + di + idata]：这种寻址方式表示的是以 bx 寄存器的值为基址，di 寄存器的值为索引，idata 为一个立即数偏移量的内存地址。例如，如果 bx 的值是 0x2000，di 的值是 0x0080，idata 的值是 0x0004，那么 [bx + di + idata] 就表示的是内存地址 0x2084。 案例：将 datasg 中每个字符改为大写字母 题目是这样的，将其中的字母都转为大写。\ndatasg SEGMENT db \u0026#39;ibm \u0026#39; db \u0026#39;dec \u0026#39; db \u0026#39;dos \u0026#39; db \u0026#39;vax \u0026#39; datasg ENDS 考虑到这类似于 C++ 中实现两层 for 循环遍历修改一样，考虑使用两层 loop 循环用汇编实现相似功能\nASSUME CS:codesg DS:datasg datasg SEGMENT db \u0026#39;ibm \u0026#39; db \u0026#39;dec \u0026#39; db \u0026#39;dos \u0026#39; db \u0026#39;vax \u0026#39; datasg ENDS codesg SEGMENT START: mov ax, codesg mov ds, ax mov bx, 0 mov cx, 4 ; 外层循环，代表每一行，总共4行 s0: mov si, 0 mov cx, 3 ; 内层循环，代表每一行的前三个字符 s: mov al, [bx + si] and al, 11011111b mov [bx + si], al inc si loop s ; 内层循环结束 add bx, 16 loop s0 ; 外层循环结束 codesg ENDS END START 这里的问题出现在，内层和外层都使用的是 cx 寄存器计数（就相当于 C++ 中，你两层循环都用 i 来迭代，这个肯定不行）。由于汇编中 loop 函数只能用 cx 寄存器计数实现，解决方法是，在进入内部的一个循环时，先将 cx 的数值暂存起来，等到里面的循环结束了之后，再恢复，这个借用 dx 寄存器来实现暂存，于是代码变成了这样：\nASSUME CS:codesg, DS:datasg datasg SEGMENT db \u0026#39;ibm \u0026#39; db \u0026#39;dec \u0026#39; db \u0026#39;dos \u0026#39; db \u0026#39;vax \u0026#39; datasg ENDS codesg SEGMENT START: mov ax, codesg mov ds, ax mov bx, 0 mov cx, 4 s0: mov dx, cx ; 使用 dx 寄存器暂存 cx 的值，用于后面的恢复 mov si, 0 mov cx, 3 s: mov al, [bx + si] and al, 11011111b mov [bx + si], al inc si loop s add bx, 16 mov cs,dx ; 恢复 cx 的值 loop s0 codesg ENDS END START 这里的问题又在于，不能想着暂存时，使用寄存器，因为寄存器的数量是有限的。这个时候，我们可以想到使用内存来实现，并且在需要暂存数据的时候，我们都应该使用栈。于是，程序可以做进一步的改进。\nASSUME CS:codesg, DS:datasg, SS:stacksg datasg SEGMENT db \u0026#39;ibm \u0026#39; db \u0026#39;dec \u0026#39; db \u0026#39;dos \u0026#39; db \u0026#39;vax \u0026#39; datasg ENDS stacksg SEGMENT dw 0, 0, 0, 0, 0, 0, 0, 0 stacksg ENDS codesg SEGMENT START: mov ax, stacksg mov ss, ax mov sp, 16 mov ax, codesg mov ds, ax mov bx, 0 mov cx, 4 s0: push cx ; 将外层循环的计数器 cx 压栈 mov si, 0 mov cx, 3 ; cx 设置为内层循环的次数 s: mov al, [bx + si] and al, 11011111b mov [bx + si], al inc si loop s add bx, 16 pop cx ; 弹出外层循环的计数器 cx, 恢复 cx loop s0 mov ax, 4c00h int 21h codesg ENDS END START ","permalink":"https://lidianzhong.gitee.io/posts/assembly/memory_location/","summary":"使用间接寻址访问内存中的指令 [0] 表示访问内存地址为 0 的位置，[bx] 表示访问内存地址为 bx 寄存器值的位置。 ; 从内存地址为 0x1000 的位置读取一个字节 mov bx, 0x1000 ; 将 0x1000 存入 bx 寄存器 mov al, [bx] ; 从内存地址为 bx 的位置读取一个字节，存入 al 寄存器 使用 and 和 or 实现内存定位 and 指令：按位进行与运算，可以将相应位设为0，","title":"内存访问"},{"content":"ESP8266 ESP8266 利用 WiFi 联网时有三种工作模式。\nStation 模式：工作在 Station 模式下的 ESP8266 就像是一个接收机一样，它可以接收来自无线路由器发出的信号。ESP8266 模块通过路由器连接互联网，手机或电脑通过互联网实现对设备的远程控制。 SoftAP 模式：无线接入点的简称，ESP8266 模块作为热点，实现手机或电脑直接与模块通信，实现局域网无线控制。 Station + SoftAP 模式：两种模式共存，既可以通过路由器连接到互联网，也可以作为 WiFi 热点，使其他设备连接到模块，实现广域网与局域网的无缝切换。 相关参考 构建过程 + 核心函数：\n基于 PlatformIO 平台玩转 NodeMCU 入门篇 | 匠心博客 (zhaomenghuan.js.org)\n","permalink":"https://lidianzhong.gitee.io/posts/embedded_system/nodemcu/nodemcu/","summary":"ESP8266 ESP8266 利用 WiFi 联网时有三种工作模式。 Station 模式：工作在 Station 模式下的 ESP8266 就像是一个接收机一样，它可以接收来自无线路由器发出的信号。ESP8266 模块通过路由器连接互联网，手机或电脑通过互联网实现对设备的远程控制。 SoftAP 模式：无线接入点的简称，ESP8266 模块作为热点，实现手机或电脑直接与模块通信","title":"NodeMCU 简介"},{"content":"1. command ‘platformio-ide.build‘ not found 解决：关闭 Vscode 再打开就好了~\n2. PlatformIO串口显示乱码 解决：串口监视器和单片机波特率不一致\n[env:nodemcuv2] platform = espressif8266 board = nodemcuv2 framework = esp8266-rtos-sdk monitor_speed = 74880 ; 监视器波特率设置 monitor_port = COM3 ; 监视器端口设置，设置为连接的串口端口 3. PlatformIO串口显示开头乱码 原因：很有可能是因为你之前烧写的程序没关，或是因为芯片自身不稳定，但只要它可以显示出你想显示的就可以。\n","permalink":"https://lidianzhong.gitee.io/posts/embedded_system/nodemcu/problem_nodemcu/","summary":"1. command ‘platformio-ide.build‘ not found 解决：关闭 Vscode 再打开就好了~ 2. PlatformIO串口显示乱码 解决：串口监视器和单片机波特率不一致 [env:nodemcuv2] platform = espressif8266 board = nodemcuv2 framework = esp8266-rtos-sdk monitor_speed = 74880 ; 监视器波特率设置 monitor_port = COM3 ; 监视器端口设置，设置为连接的串口端口 3. PlatformIO串口显示开头乱码 原因：","title":"NodeMCU 编程遇到的问题"},{"content":"嵌入式命令 查看已经安装的驱动：sudo dmesg\n查看安装的串口设备：ls -l /dev/ttyS*\n查看安装的USB转串口设备：ls -l /dev/ttyS*\n查看系统日志关于串口设备的信息：dmesg | grep ttyS\n查看 ttyS0 驱动的安装时间：ls -l /dev/ttyS0\nWindows 下查看端口命令 通用方法，Win + X，选择设备管理器，查看 COM 端口，也可点击属性信息查看\nPlatformIO Vscode 开发，点击小图标，然后输入命令：pio device list\n","permalink":"https://lidianzhong.gitee.io/posts/embedded_system/nodemcu/common_commands/","summary":"嵌入式命令 查看已经安装的驱动：sudo dmesg 查看安装的串口设备：ls -l /dev/ttyS* 查看安装的USB转串口设备：ls -l /dev/ttyS* 查看系统日志关于串口设备的信息：dmesg | grep ttyS 查看 ttyS0 驱动的安装时间：ls -l /dev/ttyS0 Windows 下查看端口命令 通用方法，Win + X，选择设备管理器，查看 COM 端口，也可点击属性信息查看 PlatformIO Vscode 开发，点","title":"嵌入式常用命令汇总"},{"content":"安装 ros2 control 安装 安装 ros2 control，humble 替换为你使用的版本\nsudo apt install ros-humble-ros2-control sudo apt install ros-humble-ros2-controllers 使用 RosTeamWS ROS工作区模板 能够快速地创建特定 ros 功能包，提供模板功能\nhttps://rtw.stoglrobotics.de/master/index.html\nros2 安装 sudo apt install ros-humble-desktop https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html\nignition gazebo 安装 ignition 为新一代的模拟题，替换了之前使用的 gazebo\nsudo wget https://packages.osrfoundation.org/gazebo.gpg -O /usr/share/keyrings/pkgs-osrf-archive-keyring.gpg echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/pkgs-osrf-archive-keyring.gpg] http://packages.osrfoundation.org/gazebo/ubuntu-stable $(lsb_release -cs) main\u0026#34; | sudo tee /etc/apt/sources.list.d/gazebo-stable.list \u0026gt; /dev/null sudo apt-get update sudo apt-get install gz-harmonic https://staging.gazebosim.org/docs/harmonic/install_ubuntu\n安装 python2 版本和 python3 版本的numpy sudo apt-get install python-numpy # python2 numpy sudo apt-get install python3-numpy # python3 numpy ","permalink":"https://lidianzhong.gitee.io/posts/robot/ros/ros_about/","summary":"安装 ros2 control 安装 安装 ros2 control，humble 替换为你使用的版本 sudo apt install ros-humble-ros2-control sudo apt install ros-humble-ros2-controllers 使用 RosTeamWS ROS工作区模板 能够快速地创建特定 ros 功能包，提供模板功能 https://rtw.stoglrobotics.de/master/index.html ros2 安装 sudo apt install ros-humble-desktop https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debians.html ignition gazebo 安装 ignition 为新一代的模拟题，替换了之前使用的 gazebo sudo wget https://packages.osrfoundation.org/gazebo.gpg -O /usr/share/keyrings/pkgs-osrf-archive-keyring.gpg echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/pkgs-osrf-archive-keyring.gpg] http://packages.osrfoundation.org/gazebo/ubuntu-stable $(lsb_release -cs) main\u0026#34; | sudo tee /etc/apt/sources.list.d/gazebo-stable.list \u0026gt; /dev/null sudo apt-get update sudo apt-get install gz-harmonic https://staging.gazebosim.org/docs/harmonic/install_ubuntu 安装 python2 版本和 python3 版本","title":"ros 相关的安装"},{"content":"\rDawn Journey\r在黎明的微光中，我们踏上了一场绚丽的旅程\r👉友链格式\r名称： Dawn Journey 网址： https://lidianzhong.gitee.io/ 图标： https://lidianzhong.gitee.io/img/Q.gif 描述： 在黎明的微光中，我们踏上了一场绚丽的旅程 ","permalink":"https://lidianzhong.gitee.io/links/","summary":"Dawn Journey 在黎明的微光中，我们踏上了一场绚丽的旅程 👉友链格式 名称： Dawn Journey 网址： https://lidianzhong.gitee.io/ 图标： https://lidianzhong.gitee.io/img/Q.gif 描述： 在黎明的微光中，我们踏上了一场绚丽的旅程","title":"🤝友链"},{"content":"Git 命令汇总 1. 分支相关 1.1 查看当前分支\ngit branch 1.2 创建一个新分支并切换到这个分支\ngit checkout -b dev\t# 创建新分支 dev 并切换到它 1.3 切换到某个分支\ngit checkout test\t# 切换到 test 分支 1.4 删除分支\ngit branch -d test\t# 删除 test 分支，如果分支没有被合并，使用 -D 参数强制删除 1.5 重命名分支\ngit branch -m \u0026lt;old_branch_name\u0026gt; \u0026lt;new_branch_name\u0026gt; 2. 撤销相关 2.1 撤销最近的一次提交\ngit reset --hard HEAD~1\t# 撤销最近的一次提交 ","permalink":"https://lidianzhong.gitee.io/posts/tools/git/git-command-overall/","summary":"Git 命令汇总 1. 分支相关 1.1 查看当前分支 git branch 1.2 创建一个新分支并切换到这个分支 git checkout -b dev # 创建新分支 dev 并切换到它 1.3 切换到某个分支 git checkout test # 切换到 test 分支 1.4 删除分支 git branch -d test # 删除 test 分支，如果分支没有被合并，使用 -D 参数强制删除 1.5 重命名分支 git branch -m \u0026lt;old_branch_name\u0026gt; \u0026lt;new_branch_name\u0026gt; 2. 撤销相关 2.1 撤销最近的一次提交 git reset --hard HEAD~1 # 撤销最近的","title":"Git 命令汇总"},{"content":" 在我们想要将本地的代码提交到Github远程仓库时，会因为网络问题，拉取失败。\n解决Git提交拉取时的网络问题 查询以下网址对应的DNS服务器地址: DNS查询工具 github.com github.global.ssl.fastly.net assets-cdn.github.com 修改 hosts 文件 20.205.243.166 github.com 66.220.148.145 github.global.ssl.fastly.net 185.199.111.153 assets-cdn.github.com # https://tool.chinaz.com/dns/github.com # https://tool.chinaz.com/dns/github.global.ssl.fastly.net # https://tool.chinaz.com/dns/assets-cdn.github.com 解决 Git clone 时的网络问题 加个fast：https://github.com/ 改为 https://githubfast.com/ 使用镜像仓库：Github镜像仓库 ","permalink":"https://lidianzhong.gitee.io/posts/tools/git/solve-git-slow-problem/","summary":"在我们想要将本地的代码提交到Github远程仓库时，会因为网络问题，拉取失败。 解决Git提交拉取时的网络问题 查询以下网址对应的DNS服务器地址: DNS查询工具 github.com github.global.ssl.fastly.net assets-cdn.github.com 修改 hosts 文件 20.205.243.166 github.com 66.220.148.145 github.global.ssl.fastly.net 185.199.111.153 assets-cdn.github.com # https://tool.chinaz.com/dns/github.com # https://tool.chinaz.com/dns/github.global.ssl.fastly.net # https://tool.chinaz.com/dns/assets-cdn.github.com 解决 Git clone 时的网络问题 加个fast：https://github.com/ 改为 https://githubfast.com/ 使用","title":"解决Git同步访问慢的问题"},{"content":" 后续开发的算法，最终结果都是生成发送给这12个关节电机的命令\n四足机器人的动力系统 1. 永磁同步电机（PMSM） 通过控制定子上三个线圈的电流，可以控制电机的力矩和角度。这种控制方法叫做矢量控制（FOC）。\n2. 关节电机的混合控制 关节电机的内部，已经封装了电机底层的控制算法。作为用户，只要给关节电机发送相关的命令，电机就能完成从接收命令到关节力矩输出的工作。\n控制指令有五个：前馈力矩、期望角度位置、期望角速度、位置刚度、速度刚度（阻尼）\n3. 关节电机的命令下发 通过 RS485 接口进行通信，用上位机控制需要使用 USB 转 RS485 转接器。\n4. 使用Python代码控制电机 指定七个参数，分别为id、mode和前面说的5个控制指令（T、W、Pos、K_P、K_W），作为结构体数据。结构体数据先要依据通信协议将数据编码为电机能够接收的格式，然后就能给电机发送命令。电机返回的数据也要通过解码再进行下一步的数据处理。\n电机只有在接收到命令时才会返回当前自身状态，所以如果只是让电机持续运转，那么不需要持续发同一条命令，为了时刻检测电机状态，才需要持续发送命令。\n用结构体中的mode参数来控制电机的控制模式。\n位置模式：电机的输出轴稳定在一个固定的位置；\n速度模式：电机稳定在一个固定的速度，\n阻尼模式：在被外力旋转时，会产生一个抗阻力矩。方向与旋转方向相反，大小与旋转速度成正比；力矩模式，电机输出一个恒定力矩；\n零力矩模式：保持力矩为0，转动输出轴的阻力会明显小于未开机时的阻力；\n混合模式（最常用）：发送前馈力矩、目标角度、目标角速度混合控制。\n5. 移植到其他上位机 根据电机发送的报文格式，通过 RS-485 协议标准，进行串口通信\n","permalink":"https://lidianzhong.gitee.io/posts/robot/robot_book/2_guan_jie_dian_ji/","summary":"后续开发的算法，最终结果都是生成发送给这12个关节电机的命令 四足机器人的动力系统 1. 永磁同步电机（PMSM） 通过控制定子上三个线圈的电流，可以控制电机的力矩和角度。这种控制方法叫做矢量控制（FOC）。 2. 关节电机的混合控制 关节电机的内部，已经封装了电机底层的控制算法。作为用户，只要给","title":"四足机器人关节电机"},{"content":"\n关于我\rDawn Journey\r在黎明的微光中，我们踏上了一场绚丽的旅程\r一首诗\r轮台东门送君去，去时雪满天山路。\r峰回路转不见君，雪上空留马行处。\r本站建于 2024 年 4 月 1 日\n","permalink":"https://lidianzhong.gitee.io/about/","summary":"关于我 Dawn Journey 在黎明的微光中，我们踏上了一场绚丽的旅程 一首诗 轮台东门送君去，去时雪满天山路。 峰回路转不见君，雪上空留马行处。 本站建于 2024 年 4 月 1 日","title":"🙋🏻‍♂️关于"}]